0.	CONTENTS
	1.	CODE DECRIPTION
	2.	FILES
	3.	PARAMETERS
	4.	MANUALLY COMPILING & RUNNING THE CODE
	5.	OUTPUT FILES
	6.	MAKEFILE
	7.	run.sh
	8.	RUNNING ON MORAR
	9.	RUNNING ON ARCHER


1.	CODE DESCRIPTION

The function of this code is to demonstrate the halo streaming algorithm, as well as to compare its performance to halo exchange. The problem being solved in the code is a standard iterated explicit update of a one-dimensional array using a 3-point stencil. The update simply involves each data element being replaced with the average of itself and its two neighbours. The code solves the problem a number of times using both halo streaming and halo exchange. The execution times are recorded and written to file, as well as the average and standard deviation of those times. The final state of the updated arrays are also written to binary files, which can easily be compared using 'diff'.


2.	FILES

The following files should be included:

	main.c - Source code
	Makefile - For easy compilation of the code
	run.sh - General script for compiling and running the code on a set number of cores
	morar_run.sh - Script for submitting and running the code on Morar
	archer_run.sh - Script for submitting and running the coed on ARCHER
	halo.sge - Morar submission script


3.	PARAMETERS

The code contains several parameters that can be altered to change the nature of the problem being solved. These can all be found and easily edited at the start of main.c.

	array_size - The number of data elements in the work array
	per_process - If this value is 1 then the array_size defined above will be the number of data elements per process. If it is 0 then array_size refers to the global number of data elements.
	iterations - The number of iterations of updates that the code will perform
	send_buffer_size & receive_buffer_size - These change the number of outstanding Sends and Receives that the halo streaming code can have outstanding at any one time. The current version of the code needs these two number to be equal to be able to run.
	message_size - The number of iterations of data that are grouped into a single message by the halo streaming code. This should divide evenly into both array_size and iterations. It should less than half of the array size per process so that each process will have enough starting information to generate a message that large.
	num_runs - The number of trials that are to be performed.


4.	MANUALLY COMPILING & RUNNING THE CODE

The code can be compiled using mpicc. The maths library must be included using -lm. It can then be run using 'mpiexec <number of processes> ./<executable name> <file identifier>'. This last argument is used as part of the name of the timing output file so that it can be distinguished from output files generated by other jobs.


5.	OUTPUT FILES

The code generates three outputs files:

	data<file identifier>.txt - This file contains the timing data from both the streaming and exchange codes. It also contains some of the parameters that were used.
	streaming_out.bin - Binary output of the final state of the halo streaming work array.
	exchange_out.bin - Binary output of the final state of the halo exchange work array.

These last two files are compared to verify the correctness of the code.


6.	MAKEFILE

The Makefile is used to easily compile the code. The following commands can be used:

	make - Compiles the code using mpicc.
	make clean - Deletes all object files and binary files, as well as various other files that can be generated by some of the other included scripts.
	make vamp -	Compiles the code with Vampir to allow for profiling. Should not be used to obtain timing results.
	make archer - For use on ARCHER only. Compiles the code using cc since mpicc is not available on ARCHER.


7.	run.sh

This is a simple script used to compile, run, and verify the output of the code. It can be run using the command 'bash run.sh <number of processes>'. The script will remove unnecessary files, compile the code using mpicc, and run it on the number of processes specified. The number of processes will also be used as the file identifier. After the program is complete, the script converts the binary output files into normal text files and compares them using 'diff'. This script can be used to quickly test the code.


8.	RUNNING ON MORAR

The easiest way to run the code on Morar is to use the file morar_run.sh. This is done using the command 'bash morar_run.sh <number of processes>'. This will compile the code and submit a job to Morar using the submission script halo.sge. The number of processes will also be used as the file identifier. halo.sge executes the job on Morar using the specified number of processes. It then converts the binary output files into normal text files and compares them using 'diff'.


9.	RUNNING ON ARCHER

Running the code on ARCHER must be done via the ARCHER login nodes. The script archer_run.sh is can be used, using the command 'bash archer_run.sh <number of processes> <number of processes per node>'. Note that ARCHER's nodes contain two 12-core processors so 24 processes per node will use the entire node. The script uses bolt to create a submission script with the required number of processes and processes per node. This submission script uses the number of processes as the file identifier. The code is then compiled using cc and the job is submitted to ARCHER.

The maximum wall time and queue are both specified in archer_run.sh. These must be changed manually if necessary.
